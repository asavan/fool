"use strict";(self.webpackChunkfool=self.webpackChunkfool||[]).push([[970],{970:(n,e,o)=>{o.r(e),o.d(e,{default:()=>m});const t=["blue","red"];function c(n){}let s="",a="";const r={recv:c,open:c,socket_open:c,socket_close:c,close:c,error:c};function i(n,e,o){const t={from:s,to:a,action:n,data:e};return o.send(JSON.stringify(t))}function l(n){for(const e of t)if(n!==e)return e;return""}function d(n,e,o){const t=new WebSocket(n),d={onmessage:c,send:(n,e)=>i(n,e,t),close:()=>{r.error=c,t.close()}};return t.onopen=function(n){r.socket_open(),o||(s=e,a=l(e),i("connected",{color:s},t))},t.onclose=function(n){r.socket_close()},t.onmessage=function(n){if(n.data instanceof Blob){const e=new FileReader;e.onload=()=>{d.onmessage(e.result)},e.readAsText(n.data)}else d.onmessage(n.data)},t.onerror=function(n){r.error(function(n){const e={};for(let o in n)e[o]=n[o];return JSON.stringify(e,((n,e)=>e instanceof Node?"Node":e instanceof Window?"Window":e)," ")}(n))},d}const f=function(n,e){const o="server"===n.currentMode;let t=null,c=!1;function a(n,e){t=n,t.onmessage=function(n){r.recv(n.data)},t.onopen=function(){c=!0,e.send("close",{}),e.close(),r.open()},t.onclose=function(){c=!1},t.onerror=function(){}}return{connect:function(){const c=n.wh?n.wh:"https:"===e.protocol?null:"ws://"+e.hostname+":"+n.wsPort;if(null==c)throw"Can't determine ws address";const i=n.color,l=d(c,i,o),f=new RTCPeerConnection;f.onicecandidate=function(n){n&&l.send("candidate",n.candidate)},f.oniceconnectionstatechange=()=>{"failed"===f.iceConnectionState&&f.restartIce()};let u=!1;const p="red"===i;let g=!1,m=!1;f.onnegotiationneeded=async()=>{try{u=!0,await f.setLocalDescription(),l.send("description",f.localDescription)}catch(n){}finally{u=!1}},f.ondatachannel=n=>{(null==t||p)&&a(n.channel,l)},l.onmessage=async function(n){const e=JSON.parse(n);if(e.from!==s)if(o)r.server_message(e);else if("candidate"===e.action)f.addIceCandidate(e.data).catch((n=>{}));else if("description"===e.action){const n=e.data,o=!u&&("stable"==f.signalingState||m),t="offer"==n.type&&!o;if(g=!p&&t,g)return;m="answer"==n.type,await f.setRemoteDescription(n),m=!1,"offer"==n.type&&(await f.setLocalDescription(),l.send("description",f.localDescription))}else"connected"===e.action?a(f.createDataChannel("gamechannel"),l):e.action}},sendMessage:function(n){return!!t&&(!!c&&(t.send(n),c))},on:function(n,e){r[n]=e},getOtherColor:l}};const u=function(n){return{move:async e=>n.onChange(e)}};var p=o(392);function g(n,e){const o={method:e};return o[e]=n,JSON.stringify(o)}function m(n,e,o,t){return new Promise(((c,s)=>{const a=f(o,n.location),r=e.getElementsByClassName("log")[0];a.on("error",(n=>{(0,p.cM)(o,n,r)})),a.on("socket_open",(()=>{const n=e.getElementsByClassName("grid")[0];n.style.backgroundColor="#AA0000",a.on("socket_close",(()=>{n.style.backgroundColor="black"}))})),a.on("open",(()=>{const s=t(n,e,o),r=u(s);a.on("recv",(n=>{const e=JSON.parse(n),o=e[e.method],t=r[e.method];"function"==typeof t&&t(o)}));for(const[n,e]of Object.entries(r))s.on(n,(e=>a.sendMessage(g(e,n))));c(s)}));try{a.connect()}catch(n){(0,p.cM)(o,n,r),s(n)}}))}}}]);